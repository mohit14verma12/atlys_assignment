# -*- coding: utf-8 -*-
"""atlys_assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T-IEjdVlAC-UNUXteAm85quIiMvpgkhY
"""

import requests
import sqlite3
import pandas as pd

def get_data(company, apikey):
  # replace the "demo" apikey below with your own key from https://www.alphavantage.co/support/#api-key
  url = f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={company}&apikey={apikey}&outputsize=full'
  r = requests.get(url)
  data = r.json()
  if 'Error Message' not in data:
    print(data)
  return data

def data_preprocessing(companies, apikey):
  final_data = []
  for company in companies:
    data = get_data(company,apikey)
    if 'Error Message' not in data:
      daily_data_points = data['Time Series (Daily)']
      start_date = '2020-01-01'
      end_date = '2024-05-31'
      for date in daily_data_points:
        # [date , Company, Open, Close, High, Low, Volume]
        open= daily_data_points[date]['1. open']
        high= daily_data_points[date]['2. high']
        low= daily_data_points[date]['3. low']
        close = daily_data_points[date]['4. close']
        volume = daily_data_points[date]['5. volume']
        if date >= start_date and date <= end_date:
          record = [date, company, open, close, high, low, volume]
          final_data.append(record)
  return final_data

# Data Preprocessing
companies = ["LT","INFY", "SBIN", "BHARTIARTL", "ICICIBANK", "HDFCBANK", "RELIANCE", "HINDUNILVR", "ITC","IBM", "TCS"]
apikey = 'SNSJWUIV9ZN42UVQ'
final_data = data_preprocessing(companies, apikey)

columns = ['date', 'company', 'open', 'close', 'high', 'low', 'volume']
final_df = pd.DataFrame(final_data, columns=columns)

#TASK 3
# Create a connection to the SQLite database
conn = sqlite3.connect(f'data.db'
                      #  ,user="username",
                      #  password="password",
                      #  host="host",
                      #  port="port"
                      )
cursor = conn.cursor()

# Create a table
cursor.execute('''
    CREATE TABLE IF NOT EXISTS historical_data (
        Date TEXT,
        Company TEXT,
        Open REAL,
        Close REAL,
        High REAL,
        Low REAL,
        Volume INTEGER
    )
''')

# Insert data into the table
final_df.to_sql('historical_data', conn, if_exists='replace', index=False)
conn.commit()

# TASK ============================== 1
def get_historical_data(conn, company):
  query = f'''SELECT *
          FROM
              historical_data
          where Company = '{company}'
          order by Date desc;'''
  results = pd.read_sql_query(query, conn)
  return results
# TASK =============================== 2
def get_yesterday_data(conn, company):
  query = f'''SELECT *
            FROM historical_data
            where Company = '{company}'
            ORDER BY Date DESC
            LIMIT 1 OFFSET 1;'''
  results = pd.read_sql_query(query, conn)
  return results

def run_query(query):
  results = pd.read_sql_query(query, conn)
  return results

res = get_historical_data(conn, "INFY")
print(res)

result = get_yesterday_data(conn, "INFY")
print(result)

# TASK ========================= 4
# Indexing for Company Wise Daily Variation of Prices and Company Wise Daily Volume Change
daily_change_indexing = '''CREATE INDEX idx_company_date ON historical_data (Date);'''
query0 = '''SELECT Company, Date, Volume
            FROM historical_data
            ORDER BY Date;'''

# Indexing for Median Daily Variation
median_indexing = '''CREATE INDEX idx_company_date_prices ON historical_data (Company, Date, Close, Open);'''

query = f'''WITH ranked_variations AS (
          SELECT
              Company,
              Date,
              (Close - Open) AS Daily_Variation,
              ROW_NUMBER() OVER (PARTITION BY Company ORDER BY (Close - Open)) AS row_num,
              COUNT(*) OVER (PARTITION BY Company) AS total_count
          FROM historical_data
      )
      SELECT
          Company,
          AVG(Daily_Variation) AS Median_Daily_Variation
      FROM ranked_variations
      WHERE row_num IN (total_count / 2 + 1, (total_count + 1) / 2)
      GROUP BY Company'''

print(run_query(query))

